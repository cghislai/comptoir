import { isPresent, BaseException } from 'angular2/src/facade/lang';
import { ListWrapper } from 'angular2/src/facade/collection';
import { ChangeDetectorRef } from './change_detector_ref';
import { ChangeDetectionError } from './exceptions';
import { CHECK_ONCE, CHECKED, DETACHED } from './constants';
class _Context {
    constructor(element, componentElement, instance, context, locals, injector, expression) {
        this.element = element;
        this.componentElement = componentElement;
        this.instance = instance;
        this.context = context;
        this.locals = locals;
        this.injector = injector;
        this.expression = expression;
    }
}
export class AbstractChangeDetector {
    constructor(id, dispatcher) {
        this.id = id;
        this.dispatcher = dispatcher;
        this.lightDomChildren = [];
        this.shadowDomChildren = [];
        this.mode = null;
        this.ref = new ChangeDetectorRef(this);
    }
    addChild(cd) {
        this.lightDomChildren.push(cd);
        cd.parent = this;
    }
    removeChild(cd) { ListWrapper.remove(this.lightDomChildren, cd); }
    addShadowDomChild(cd) {
        this.shadowDomChildren.push(cd);
        cd.parent = this;
    }
    removeShadowDomChild(cd) { ListWrapper.remove(this.shadowDomChildren, cd); }
    remove() { this.parent.removeChild(this); }
    detectChanges() { this.runDetectChanges(false); }
    checkNoChanges() { throw new BaseException("Not implemented"); }
    runDetectChanges(throwOnChange) {
        if (this.mode === DETACHED || this.mode === CHECKED)
            return;
        this.detectChangesInRecords(throwOnChange);
        this._detectChangesInLightDomChildren(throwOnChange);
        if (throwOnChange === false)
            this.callOnAllChangesDone();
        this._detectChangesInShadowDomChildren(throwOnChange);
        if (this.mode === CHECK_ONCE)
            this.mode = CHECKED;
    }
    detectChangesInRecords(throwOnChange) { }
    hydrate(context, locals, directives, pipes) { }
    hydrateDirectives(directives) { }
    dehydrate() { }
    dehydrateDirectives(destroyPipes) { }
    callOnAllChangesDone() { }
    _detectChangesInLightDomChildren(throwOnChange) {
        var c = this.lightDomChildren;
        for (var i = 0; i < c.length; ++i) {
            c[i].runDetectChanges(throwOnChange);
        }
    }
    _detectChangesInShadowDomChildren(throwOnChange) {
        var c = this.shadowDomChildren;
        for (var i = 0; i < c.length; ++i) {
            c[i].runDetectChanges(throwOnChange);
        }
    }
    markAsCheckOnce() { this.mode = CHECK_ONCE; }
    markPathToRootAsCheckOnce() {
        var c = this;
        while (isPresent(c) && c.mode != DETACHED) {
            if (c.mode === CHECKED)
                c.mode = CHECK_ONCE;
            c = c.parent;
        }
    }
    throwError(proto, exception, stack) {
        var c = this.dispatcher.getDebugContext(proto.bindingRecord.elementIndex, proto.directiveIndex);
        var context = isPresent(c) ? new _Context(c.element, c.componentElement, c.directive, c.context, c.locals, c.injector, proto.expressionAsString) :
            null;
        throw new ChangeDetectionError(proto, exception, stack, context);
    }
}
//# sourceMappingURL=abstract_change_detector.js.map